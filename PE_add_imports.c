/*
 *  _           _ _   
 * | |         | | |  
 * | |__   ___ | | |_ 
 * | '_ \ / _ \| | __|
 * | |_) | (_) | | |_ 
 * |_.__/ \___/|_|\__|
 *
 * Written by Dennis Yurichev <dennis(a)yurichev.com>, 2013
 *
 * This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License. 
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/3.0/.
 *
 */

/*
 * new imports table is created (newidata).
 * old imports table is still here: FirstThunk arrays will be used from there
 * fixups table is fixed if needed
 */

#include <windows.h>
#include <stdbool.h>
#include "oassert.h"
#include <dbghelp.h>
#include "bolt_mingw_addons.h"
#include "memutils.h"
#include "PE.h"
#include "PE_imports.h"
#include "stuff.h"
#include "logging.h"
#include "dmalloc.h"
#include "bitfields.h"
#include "porg_utils.h"
#include "ostrings.h"
#include "x86.h"
#include "dmalloc.h"

#define NEW_IMPORT_SECTION_NAME "newidata"
#define DONT_RUN_TWICE "please don't run this utility twice!"
#define COPYRIGHT "\nthis import table was (re)generated by PE_add_import utility written by dennis@yurichev.com available at http://www.yurichev.com/PE_add_imports.html\n"

struct imports_table
{
	address a;
	char* dll;
	char* func_name;
	struct imports_table *next;
};

struct imports_table *table=NULL;
unsigned imports_table_t=0;

void load_imports_table(char *fname)
{
	FILE* hdl=fopen (fname, "rt");
	if (hdl==NULL)
		die ("can't open %s file\n", fname);
	
	
	unsigned line=1;
	for (;;line++)
	{
		char DLL_name[128];
		char sym_name[128];
		address fn_adr;

		if (fscanf (hdl, "0x" PRI_ADR_HEX " %128[^!]!%128[^\n]\n", &fn_adr, DLL_name, sym_name)==3)
		{
			struct imports_table* t;
			if (table==NULL)
				t=table=DCALLOC(struct imports_table, 1, "struct imports_table");
			else
			{
				for (t=table; t->next; t=t->next); // find last
				t->next=DCALLOC(struct imports_table, 1, "struct imports_table");
				t=t->next;
			};

			t->a=fn_adr;
			t->dll=DSTRDUP(DLL_name, "char*");
			t->func_name=DSTRDUP(sym_name, "char*");
			line++;
			imports_table_t++;
		}
		else
		{
			//printf ("can't parse line %d in %s\n", line, imports_table);
			break;
		};
	};
	if (table==NULL)
		die ("no lines processed from %s\n", fname);

	fclose(hdl);
};

void free_imports_table(struct imports_table *t)
{
	if (t==NULL)
		return;
	DFREE(t->dll);
	DFREE(t->func_name);
	free_imports_table(t->next);
	DFREE(t);
};

LOADED_IMAGE im;
DWORD *fixups, *new_fixups;
size_t fixups_t;
bool fixups_changed=false;
struct PE_get_imports_info *i_tbl;

void remove_fixups_in_region(address begin, address end)
{
	for (size_t i=0; i<fixups_t; i++)
		if (VAL_IN_BOUNDS_INCL (fixups[i], begin, end) ||
				VAL_IN_BOUNDS_INCL (fixups[i]+sizeof(address), begin, end))
		{
			//printf ("removing fixup %d (0x%x)\n", i, fixups[i]);
			fixups[i]=UINT32_MAX;
			fixups_changed=true;
		};
};

void add_JMP(struct imports_table *t)
{
#ifdef _WIN64
#define INS_LEN X64_JMP_REL_IMM32_LEN
#else
#define INS_LEN X86_JMP_ABS_IMM32_LEN
#endif
	address pnt_RVA=t->a - PE_get_original_base (&im);
	// there are shouldn't be any fixups on the newly inserted instruction!
	remove_fixups_in_region(pnt_RVA, pnt_RVA+INS_LEN);

	// x86: FF 25 xx xx xx xx (absolute address). FIXUP should be here.
	// x64: 48 FF 25 xx xx xx xx (relative to the next label)
	byte* pnt_VA=(byte*)ImageRvaToVa (im.FileHeader, im.MappedAddress, pnt_RVA, NULL);
#ifdef _WIN64
	memcpy (pnt_VA, X64_JMP_REL_IMM32, X64_JMP_REL_IMM32_LEN);
#else
	memcpy (pnt_VA, X86_JMP_ABS_IMM32, X86_JMP_ABS_IMM32_LEN);
#endif
	// find FirstThunk place for this dll!func_name
	address thunk_place=PE_find_thunk_by_import (i_tbl, t->dll, t->func_name);
#ifdef _WIN64
	DWORD to_write=thunk_place - pnt_RVA - X64_JMP_REL_IMM32_LEN;
	*(DWORD*)(pnt_VA+X64_JMP_REL_IMM32_OFS_TO_IMM32)=to_write;
#else		
	DWORD to_write=thunk_place + PE_get_original_base (&im);
	*(DWORD*)(pnt_VA+X86_JMP_ABS_IMM32_OFS_TO_IMM32)=to_write;
	// FIXUP should be also applied.
	*new_fixups=pnt_RVA+X86_JMP_ABS_IMM32_OFS_TO_IMM32;
	//printf ("new fixup=0x%x\n", *new_fixups);
	new_fixups++;
	fixups_changed=true;
#endif
};

void add_JMPs()
{
	// FirstThunk is now present in the i_tbl for DLLs added
	for (struct imports_table *t=table; t; t=t->next)
		add_JMP(t);
};

void rebuild_fixups_section()
{
	//printf ("fixups_t=%d\n", fixups_t);
	// remove all -1 from array
	tetrabyte_array_remove_all_values((tetrabyte**)&fixups, UINT32_MAX, &fixups_t, true /*call_drealloc*/);
	//printf ("new fixups_t=%d\n", fixups_t);

	qsort (fixups, fixups_t, sizeof(DWORD), &qsort_compare_tetrabytes);
	//for (unsigned i=0; i<fixups_t; i++)
	//	printf ("new fixup 0x%x\n", fixups[i]);

	size_t fixup_section_size;
	byte* fixups_section=generate_fixups_section (fixups, fixups_t, &fixup_section_size);

	size_t reloc_directory_size;
	tetrabyte *reloc_directory=PE_get_reloc_directory (&im, PE_is_PE32(&im), &reloc_directory_size);

	if (fixup_section_size > reloc_directory_size)
		die ("generated reloc section is bigger than what is in original file. sorry.\n"); // FIXME

	// clear fixup section first.
	bzero (reloc_directory, reloc_directory_size);
	// copy new fixup section
	memcpy (reloc_directory, fixups_section, fixup_section_size);
	DFREE(fixups_section);
};

int main(int argc, char* argv[])
{
	printf ("Simple tool for adding symbols to PE executable import table\n");
	printf ("<dennis@yurichev.com> (%s %s)\n", __DATE__, __TIME__);
	if(argc!=3)
	{
		printf ("usage: fname.exe imports_table");
		printf ("for example: winword.exe imports_table.txt\n");
		printf ("imports_table.txt is a text file consisting of DLL name, symbol and address:\n");
		printf ("0x00401234 mydll1.dll!MyFunction1\n");
		printf ("0x00405678 mydll2.dll!MyFunction2\n");
		printf ("etc\n");
		return 1;
	};

	char *fname=argv[1];
	load_imports_table (argv[2]);

	MapAndLoad_or_die (fname, NULL, &im, false, /* ReadOnly */ false);

	if (PE_find_section_by_name (&im, NEW_IMPORT_SECTION_NAME))
		die ("%s there are section named %s in %s\n",
				DONT_RUN_TWICE, NEW_IMPORT_SECTION_NAME, fname);

	i_tbl=PE_get_imports (&im);
	if (i_tbl==NULL)
		die ("%s: no imports\n", fname); // FIXME

	for (struct imports_table *t=table; t; t=t->next)
		add_DLL_and_symbol_to_imports (i_tbl, t->dll, t->func_name, 0 /* hint */);

	// calculate RVA for new section
	address next_available_RVA, next_available_phys_ofs;
	calculate_next_available_RVA_and_phys_ofs(&im, &next_available_RVA, &next_available_phys_ofs);

	i_tbl->start_RVA=next_available_RVA; // of new section
	size_t approx_tbl_size=PE_approx_import_table_size (i_tbl);
	size_t bufsize=approx_tbl_size*2;
	byte* buf=DMALLOC(byte, bufsize, "byte*");
	bzero(buf, bufsize);
	size_t size_of_IMAGE_DIRECTORY_ENTRY_IMPORT;
	size_t new_tbl_size=PE_generate_import_table (i_tbl, buf, bufsize, 
			&size_of_IMAGE_DIRECTORY_ENTRY_IMPORT);
	// add "copyright"!
	strcpy ((char*)buf+new_tbl_size+1, COPYRIGHT);

	size_t new_sect_size_of_raw_data=add_PE_section_at_end(&im, NEW_IMPORT_SECTION_NAME, 
			new_tbl_size+strlen(COPYRIGHT), 
			IMAGE_SCN_MEM_READ + IMAGE_SCN_MEM_WRITE + IMAGE_SCN_CNT_INITIALIZED_DATA);

	// fix directory entry for imports
	set_data_directory_entry(&im, IMAGE_DIRECTORY_ENTRY_IMPORT, next_available_RVA, size_of_IMAGE_DIRECTORY_ENTRY_IMPORT);

	// read fixups
	fixups=make_array_of_fixups (&im, &fixups_t);
	//printf ("fixups_t=%d\n", fixups_t);
	//for (unsigned i=0; i<fixups_t; i++)
	//	printf ("original fixup 0x%x\n", fixups[i]);
	new_fixups=fixups+fixups_t;
	fixups_t+=imports_table_t;
	fixups=DREALLOC(fixups, DWORD, fixups_t, "fixups");

	// now add JMP-s
	add_JMPs();

	PE_get_imports_info_free(i_tbl);

	// rebuild fixups if needed
	if (fixups_changed)
		rebuild_fixups_section();

	UnMapAndLoad_or_die (&im);

	// write import table at the end of file
	write_to_the_end_of_file_or_die (fname, buf, new_sect_size_of_raw_data);
	DFREE(buf);
	DFREE(fixups);

	PE_fix_checksum (fname);	

	free_imports_table(table);
	
	dump_unfreed_blocks();
};
