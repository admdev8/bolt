/*
 *  _           _ _   
 * | |         | | |  
 * | |__   ___ | | |_ 
 * | '_ \ / _ \| | __|
 * | |_) | (_) | | |_ 
 * |_.__/ \___/|_|\__|
 *
 * Written by Dennis Yurichev <dennis(a)yurichev.com>, 2013
 *
 * This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License. 
 * To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/3.0/.
 *
 */

/*
 * new imports table is created (newidata).
 * old imports table is still here: FirstThunk arrays will be used from there
 */

#include <windows.h>
#include <stdbool.h>
#include "oassert.h"
#include <dbghelp.h>
#include "bolt_mingw_addons.h"
#include "memutils.h"
#include "PE.h"
#include "PE_imports.h"
#include "stuff.h"
#include "logging.h"
#include "dmalloc.h"
#include "bitfields.h"
#include "porg_utils.h"
#include "ostrings.h"

#define NEW_IMPORT_SECTION_NAME "newidata"
#define DONT_RUN_TWICE "please don't run this utility twice!"
#define COPYRIGHT "\nthis import table was (re)generated by PE_add_import utility written by dennis@yurichev.com available at http://www.yurichev.com/PE_add_import.html\n"

struct imports_table
{
	address a;
	char* dll;
	char* func_name;
	struct imports_table *next;
};

struct imports_table *table=NULL;

void load_imports_table(char *fname)
{
	FILE* hdl=fopen (fname, "rt");
	if (hdl==NULL)
		die ("can't open %s file\n", fname);
	
	
	unsigned line=1;
	for (;;line++)
	{
		char DLL_name[128];
		char sym_name[128];
		address fn_adr;

		if (fscanf (hdl, "0x" PRI_ADR_HEX " %128[^!]!%128[^\n]\n", &fn_adr, DLL_name, sym_name)==3)
		{
			struct imports_table* t;
			if (table==NULL)
				t=table=DCALLOC(struct imports_table, 1, "struct imports_table");
			else
			{
				for (t=table; t->next; t=t->next); // find last
				t->next=DCALLOC(struct imports_table, 1, "struct imports_table");
				t=t->next;
			};

			t->a=fn_adr;
			t->dll=DSTRDUP(DLL_name, "char*");
			t->func_name=DSTRDUP(sym_name, "char*");
			line++;
		}
		else
		{
			//printf ("can't parse line %d in %s\n", line, imports_table);
			break;
		};
	};
	if (table==NULL)
		die ("no lines processed from %s\n", fname);

	fclose(hdl);
};

void free_imports_table(struct imports_table *t)
{
	if (t==NULL)
		return;
	DFREE(t->dll);
	DFREE(t->func_name);
	free_imports_table(t->next);
	DFREE(t);
};

int main(int argc, char* argv[])
{
	printf ("Simple tool for adding symbols to PE executable import table\n");
	printf ("<dennis@yurichev.com> (%s %s)\n", __DATE__, __TIME__);
	if(argc!=3)
	{
		printf ("usage: fname.exe imports_table");
		printf ("for example: winword.exe imports_table.txt\n");
		printf ("imports_table.txt is a text file consisting of DLL name, symbol and address:\n");
		printf ("0x00401234 mydll1.dll!MyFunction1\n");
		printf ("0x00405678 mydll2.dll!MyFunction2\n");
		printf ("etc\n");
		return 1;
	};

	char *fname=argv[1];

	load_imports_table (argv[2]);

	LOADED_IMAGE im;

	MapAndLoad_or_die (fname, NULL, &im, false, /* ReadOnly */ false);

	if (PE_find_section_by_name (&im, NEW_IMPORT_SECTION_NAME))
		die ("%s there are section named %s in %s\n",
				DONT_RUN_TWICE, NEW_IMPORT_SECTION_NAME, fname);

	struct PE_get_imports_info* i_tbl=PE_get_imports (&im);
	if (i_tbl==NULL)
		die ("%s: no imports\n", fname);

	wyde hint=1;
	for (struct imports_table *t=table; t; t=t->next)
		add_DLL_and_symbol_to_imports (i_tbl, t->dll, t->func_name, hint++ /* hint */);

	// calculate RVA for new section
	address next_available_RVA, next_available_phys_ofs;
	calculate_next_available_RVA_and_phys_ofs(&im, &next_available_RVA, &next_available_phys_ofs);

	i_tbl->start_RVA=next_available_RVA; // of new section
	byte buf[0x8000]; // FIXME! but I need tests...
	bzero(buf, sizeof(buf));
	size_t size_of_IMAGE_DIRECTORY_ENTRY_IMPORT;
	size_t new_tbl_size=PE_generate_import_table (i_tbl, buf, sizeof(buf), 
			&size_of_IMAGE_DIRECTORY_ENTRY_IMPORT);
	// add "copyright"!
	strcpy ((char*)buf+new_tbl_size+1, COPYRIGHT);

	size_t new_sect_size_of_raw_data=add_PE_section_at_end(&im, NEW_IMPORT_SECTION_NAME, 
			new_tbl_size+strlen(COPYRIGHT), 
			IMAGE_SCN_MEM_READ + IMAGE_SCN_MEM_WRITE + IMAGE_SCN_CNT_INITIALIZED_DATA);

	// fix directory entry for imports
	set_data_directory_entry(&im, IMAGE_DIRECTORY_ENTRY_IMPORT, next_available_RVA, size_of_IMAGE_DIRECTORY_ENTRY_IMPORT);

	// now add JMP-s
	// FirstThunk is now present in the i_tbl for DLLs added
	for (struct imports_table *t=table; t; t=t->next)
	{
		// x86: FF 25 xx xx xx xx (absolute address). FIXUP should be here.
		// x64: 48 FF 25 xx xx xx xx (relative to the next label)
		address pnt_RVA=t->a - PE_get_original_base (&im);
		byte* pnt_VA=(byte*)ImageRvaToVa (im.FileHeader, im.MappedAddress, pnt_RVA, NULL);
#ifdef _WIN64
		memcpy (pnt_VA, X64_JMP_REL_IMM32, X64_JMP_REL_IMM32_LEN);
#else
		memcpy (pnt_VA, X86_JMP_ABS_IMM32, X86_JMP_ABS_IMM32_LEN);
#endif
		// find FirstThunk place for this dll!func_name
		address thunk_place=PE_find_thunk_by_import (i_tbl, t->dll, t->func_name);

#ifdef _WIN64
		DWORD to_write=thunk_place;
		to_write-=pnt_RVA;
		to_write-=X64_JMP_REL_IMM32_LEN;
		*(DWORD*)(pnt_VA+X64_JMP_REL_IMM32_OFS_TO_IMM32)=to_write;
#else		
		DWORD to_write=thunk_place + PE_get_original_base (&im);
		*(DWORD*)(pnt_VA+X86_JMP_ABS_IMM32_OFS_TO_IMM32)=to_write;
#endif		
	};

	PE_get_imports_info_free(i_tbl);
	UnMapAndLoad_or_die (&im);

	// write import table at the end of file
	write_to_the_end_of_file_or_die (fname, buf, new_sect_size_of_raw_data);

	PE_fix_checksum (fname);	

	free_imports_table(table);
	
	dump_unfreed_blocks();
};
